//
//  RuntimeClassDetail.swift
//  MacRuntimeBrowser
//
//  Created by Phil Zakharchenko on 12/13/25.
//

import Foundation
import ObjCDump

/// Immutable, Sendable representation of a runtime class with all its details.
struct RuntimeClassDetail: Identifiable, Sendable {
    let id: TypeIdentifier
    let name: String
    let superClassName: String?
    let imagePath: String?
    let inheritanceChain: [String]
    let headerString: String
    
    init(objcClass: AnyClass) {
        let className = NSStringFromClass(objcClass)
        self.id = .className(className)
        self.name = className
        
        if let superCls = class_getSuperclass(objcClass) {
            self.superClassName = NSStringFromClass(superCls)
        } else {
            self.superClassName = nil
        }
        
        if let imageName = class_getImageName(objcClass) {
            self.imagePath = String(cString: imageName)
        } else {
            self.imagePath = nil
        }
        
        let info = ObjCClassInfo(objcClass)
        
        self.inheritanceChain = Self.buildInheritanceChain(for: className)
        
        self.headerString = Self.generateHeader(
            name: className,
            superClassName: superClassName,
            imagePath: imagePath,
            info: info
        )
    }
    
    // MARK: - Header Generation
    
    private static func generateHeader(
        name: String,
        superClassName: String?,
        imagePath: String?,
        info: ObjCClassInfo
    ) -> String {
        var lines: [String] = []
        
        lines.append("/// Generated by MacRuntimeBrowser.")
        if let path = imagePath {
            lines.append("/// Image: \(path)")
        }
        lines.append("")
        
        var decl = "@interface \(name)"
        if let superName = superClassName {
            decl += " : \(superName)"
        }
        
        let protocols = info.protocols
        if !protocols.isEmpty {
            let protocolNames = protocols.map(\.name).joined(separator: ", ")
            decl += " <\(protocolNames)>"
        }
        
        let ivars = info.ivars
        if !ivars.isEmpty {
            decl += " {"
            lines.append(decl)
            for ivar in ivars.sorted(by: { $0.name < $1.name }) {
                lines.append("    \(ivar.headerString)")
            }
            lines.append("}")
        } else {
            lines.append(decl)
        }
        
        lines.append("")
        
        let classProps = info.classProperties.sorted(by: { $0.name < $1.name })
        for prop in classProps {
            lines.append(prop.headerString)
        }
        
        let props = info.properties.sorted(by: { $0.name < $1.name })
        for prop in props {
            lines.append(prop.headerString)
        }
        
        let methodGroups = groupMethodsByImageAndCategory(
            info: info,
            className: name,
            classImagePath: imagePath
        )
        
        for (index, group) in methodGroups.enumerated() {
            let isClassImage = group.imagePath == imagePath
            
            if !isClassImage || index > 0 {
                lines.append("/// Image: \(group.imagePath ?? "unknown")")
            }
            
            for categoryGroup in group.categories {
                if let categoryName = categoryGroup.categoryName, !categoryName.isEmpty {
                    lines.append("")
                    lines.append("// \(name) (\(categoryName))")
                }
                
                lines.append("")
                
                let sortedMethods = categoryGroup.methods.sorted { m1, m2 in
                    if m1.isClassMethod != m2.isClassMethod {
                        return m1.isClassMethod
                    }
                    return m1.name < m2.name
                }
                
                for method in sortedMethods {
                    lines.append(method.headerString)
                }
            }
            
            if index < methodGroups.count - 1 {
                lines.append("")
            }
        }
        
        lines.append("")
        lines.append("@end")
        
        return lines.joined(separator: "\n")
    }
    
    private static func groupMethodsByImageAndCategory(
        info: ObjCClassInfo,
        className: String,
        classImagePath: String?
    ) -> [MethodImageGroup] {
        let allMethods = info.classMethods + info.methods
        
        var imageGroups: [String: [ObjCMethodInfo]] = [:]
        for method in allMethods {
            let path = method.filePath ?? ""
            imageGroups[path, default: []].append(method)
        }
        
        // Sort images: class's own image first, then alphabetically.
        let sortedImagePaths = imageGroups.keys.sorted { path1, path2 in
            let isPath1ClassImage = path1 == classImagePath
            let isPath2ClassImage = path2 == classImagePath
            
            if isPath1ClassImage && !isPath2ClassImage { return true }
            if !isPath1ClassImage && isPath2ClassImage { return false }
            return path1 < path2
        }
        
        var result: [MethodImageGroup] = []
        
        for imagePath in sortedImagePaths {
            let methods = imageGroups[imagePath] ?? []
            
            var categoryGroups: [String: [ObjCMethodInfo]] = [:]
            for method in methods {
                let category = method.categoryName ?? ""
                categoryGroups[category, default: []].append(method)
            }
            
            let sortedCategories = categoryGroups.keys.sorted { cat1, cat2 in
                if cat1.isEmpty && !cat2.isEmpty { return true }
                if !cat1.isEmpty && cat2.isEmpty { return false }
                return cat1 < cat2
            }
            
            let categories = sortedCategories.map { categoryName in
                MethodCategoryGroup(
                    categoryName: categoryName.isEmpty ? nil : categoryName,
                    methods: categoryGroups[categoryName] ?? []
                )
            }
            
            result.append(MethodImageGroup(
                imagePath: imagePath.isEmpty ? nil : imagePath,
                categories: categories
            ))
        }
        
        return result
    }
    
    private static func buildInheritanceChain(for className: String) -> [String] {
        var chain: [String] = []
        var currentClassName: String? = className
        
        while let name = currentClassName {
            chain.insert(name, at: 0)
            if let cls = NSClassFromString(name),
               let superCls = class_getSuperclass(cls) {
                currentClassName = NSStringFromClass(superCls)
            } else {
                currentClassName = nil
            }
        }
        
        return chain
    }
}

// MARK: - Method Grouping Helpers

private struct MethodImageGroup {
    let imagePath: String?
    let categories: [MethodCategoryGroup]
}

private struct MethodCategoryGroup {
    let categoryName: String?
    let methods: [ObjCMethodInfo]
}

